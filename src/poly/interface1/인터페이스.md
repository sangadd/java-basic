## 인터페이스   
> 자바는 순수 추상 클래스를 더 편리하게 사용할 수 있는 인터페이스라는 기능을 제공한다.   

### 순수 추상 클래스   
```
public abstract class AbstractAnimal {
    public abstract void sound();
    public abstract void move();
}
```
> 인터페이스는 class가 아니라 interface 키워드를 사용하면 된다.   

### 인터페이스   
```
public interface class InterfaceAnimal {
    public abstract void sound();
    public abstract void move();
}
```

### 인터페이스 - public, abstract 키워드 생략 가능   
```
public interface InterfaceAnimal {
    void sound();
    void move();
}
```

### 순수 추상 클래스 특징   
1. 인스턴스를 생성할 수 없다.  
2. 상속 시 자식은 모든 메서드를 오버라이딩해야 한다.  
3. 주로 다형성을 위해 사용된다.  

### 인터페이스 특징  
1. 인터페이스의 메서드는 모두 public, abstract 이다.  
2. 메서드에 public abstract 를 생략할 수 있다. 참고로 생략 권장   
3. 인터페이스는 다중 구현(다중 상속)을 지원한다.  

## 인터페이스와 멤버 변수   
```
public interface InterfaceAnimal {  
    public static final int MY_PI = 3.14;  
}
```
> 인터페이스에서 멤버 변수는 public static final 이 모두 포함되었다고 간주한다.  
> final은 변수의 값을 한 번 설정하면 수정할 수 없다는 뜻이다.   
> 자바에서 static final을 사용해 정적이면서 고칠 수 없는 변수를 상수라 하고 관례상 상수는 대문자에 언더스코어(..)로 구분한다.   

해당 키워드는 다음과 같이 생략할 수 있다. (생략 권장)  
```
public interface InterfaceAnimal {
    int MY_PI = 3.14;
}
```

- 클래스 , 추상 클래스 , 인터페이스는 모두 똑같다.   
  - 클래스, 추상 클래스, 인터페이스는 프로그램 코드, 메모리 구조상 모두 똑같다. 모두 자바에서는 .class로 다루어진다. 인터페이스를 작성할 때도 .java에 인터페이스를 정의한다.   
  - 인터페이스는 순수 추상 클래스와 비슷하다고 생각하면 된다.   
  - 자바에서는 순수 추상 클래스라는 단어가 없다. 그냥 인터페이스라고 부른다.   
  - 그래서 자바에서는 모든 메서드가 추상이면 인터페이스를 만든다고 생각하기   

### 상속 vs 구현 
부모 클래스의 기능을 자식 클래스가 상속 받을 때 클래스는 상속 받는다고 표현하지만 부모 인터페이스의 기능을 자식이 상속 받을 떄는 인터페이스를 구현한다고 표현한다.  
이렇게 서로 다르게 표현하는 이유를 알아보자   

상속은 이름 그대로 부모의 기능을 물려 받는 것이 목적이다.  
하지만 인터페이스는 모든 메서드가 추상 클래스다.   
따라서 물려받을 수 있는 기능이 없고 오히려 인터페이스에 정의한 모든 메서드를 자식이 오버라이딩해서 기능을 구현해야 한다.   
따라서 구현한다고 표현한다.   

인터페이스는 메서드 이름만 있는 설계도이고 이 설계도가 실제 어떻게 동작하는지는 하위 클래스에서 모두 구현해야 한다.   
따라서 인터페이스의 경우 상속이 아니라 해당 인터페이스를 구현한다고 표현한다.   

상속과 구현은 사람이 표현하는 단어만 다를 뿐이지 자바 입장에서는 똑같다. 일반 상속 구조와 동일하게 작동한다.   

### 인터페이스를 사용해야 하는 이유   
모든 메서드가 추상 메서드인 경우 순수 추상 클래스를 만들어도 되고 인터페이스를 만들어도 된다. 그런데 왜 인터페이스를 사용해야 할까?  
단순히 편리하다는 이유를 넘어서 다음과 같은 이유가 있다   

1. 제약 
인터페이스를 만드는 이유는 인터페이스를 구현하는 곳에서 인터페이스의 메서드를 반드시 구현하라는 규약(제약)을 주는 것이다.  
USB 인터페이스를 생각해보자 USB 인터페이스에 맞추어 키보드, 마우스를 개발하고 연결해야 한다. 그렇지 않으면 작동하지 않는다  
인터페이스의 규약(제약)은 반드시 구현해야 하는 것이다.   
그런데 순수 추상 클래스의 경우 미래에 누군가 그곳에 실행 가능한 메서드를 끼워넣을 수 있다. 이렇게 되면 추가된 기능을 자식 클래스에서 구현하지 않을 수도 있고   
또 더는 순수 추상 클래스가 아니게 된다.   
인터페이스는 모든 메서드가 추상 메서드다 따라서 이런 문제를 원천 차단 가능   

즉 !!!  
인터페이스는 여기에 있는 기능을 다 구현해야돼 !! 약속이야 규약이야 라는 의미로 만든 것  
```
public interface InterfaceAnimal {
    //    public abstract void sound(); public abstract 생략 가능
    void sound();
    void move();
}
```

근데 추상 클래스는?? 일부는 구현이 안되어 있고 또 다른 일부는 구현이 되어 있어 -> 응 괜찮아   
```
public abstract class AbstractAnimal {
    public abstract void sound();
    public abstract void move();
}
```

2. 다중 구현  
자바에서 클래스 상속은 부모를 하나만 지정할 수 있다.  
반면에 인터페이스는 부모를 여러명 두는 다중 구현(다중 상속)이 가능하다.   

> => 좋은 프로그램은 제약이 있는 프로그램이다 😊😊


**참고**  
> 자바8에 등장한 default 메서드를 사용하면 인터페이스도 메서드를 구현할 수 있다.  
> 하지만 이것은 예외적으로 아주 특별한 경우에만 사용해야 한다.  
> 자바9에서 등장한 인터페이스의 private 메서드도 마찬가지다   
> 지금 학습 단계에서는 이 부분 고려 안해도 됨 뒤에서 따로 배움   

## 인터페이스 - 다중 구현 
자바가 다중 상속을 지원하지 않는 이유 
자바는 다중 상속을 지원하지 않는다. 그래서 extends 대상은 하나만 선택할 수 있다. 
부모를 하나만 선택할 수 있다는 뜻이다. 물론 부모가 또 부모를 가지는 것은 괜찮다. 

만약 비행기와 자동차를 상속 받아서 하늘을 나는 자동차를 만든다고 가정해보자. 만약 그림과 같이 다중 상속을 사용하
게 되면 AirplaneCar 입장에서 move()를 호출할 때 어떤 부모의 move()를 사용해야 할지 애매한 문제가 발생
한다. 이것을 다이아몬드 문제라 한다. 그리고 다중 상속을 사용하면 클래스 계층 구조가 매우 복잡해지 수 있다. 이런
문제점 때문에 자바는 클래스의 다중 상속을 허용하지 않는다. 대신에 인터페이스의 다중 구현을 허용하여 이러한 문제
를 피한다.
클래스는 앞서 설명한 이유로 다중 상속이 안되는데, 인터페이스의 다중 구현은 허용한 이유는 뭘까?
인터페이스는 모두 추상 메서드로 이루어져 있기 때문이다.

