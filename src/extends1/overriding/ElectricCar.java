package extends1.overriding;

public class ElectricCar extends Car {

    @Override
    public void move(){
        System.out.println("전기차를 빠르게 이동합니다.");
    }
    /*
    ElectricCar는 부모인 Car의 move() 기능을 그대로 사용하고 싶지 않다.
    메서드 이름은 같지만 새로운 기능을 사용하고 싶어
    => 그래서 ElectricCar의 move() 메서드를 새로 만들었다.
    이렇게 부모의 기능을 자식이 새로 재정의하는 것을 메서드 오버라이딩!!!!!!!!!! 이라고 한다.

    @Override
    - @이 붙은 부분을 애노테이션이라 한다.
    - 애노테이션은 주석과 비슷한데 프로그램이 읽을 수 있는 특별한 주석이라고 생각하면 된다.

    - 이 애노테이션은 상위 클래스의 메서드를 오버라이드하는 것을 나타내고 이름 그대로 오버라이딩한 메서드 위에 이 애노테이션을 붙여야 한다.
    - 컴파일러는 이 애노테이션을 보고 메서드가 정확히 오버라이드 되었는지 확인하고
    오버라이딩 조건을 만족시키지 않으면 컴파일 에러를 발생시킨다.
    - 따라서 실수로 오버라이딩을 못하는 경우를 방지해준다.
    - 예를 들어서 이 경우에 만약 부모에 move() 메서드가 없다면 컴파일 오류가 발생한다.
    - 참고로 이 기능은 필수는 아니지만 코드의 명확성을 위해 붙여주는 것이 조아


    - 왜 붙여주는 것이 좋냐면 (개발자들은 다 붙여줌)
    - 1. @Override을 안붙여주고 메서드명 move()로 동일하지 않을 때
        ElectricCar 클래스에서 메서드명을 못찾으니까 부모로 가서 move() 메서드 호출해줌

    - 2. @Override을 붙이고 메서드명 move()로 동일하지 않을 때
    메서드명이 같지 않아도 어노테이션을 붙이면 이 메서드는 부모의 기능을 오버라이딩 할 것이라는 표식을 남기는 것과 같음
    java: method does not override or implement a method from a supertype
    (java: 메소드는 상위 유형의 메소드를 대체하거나 구현하지 않습니다.)
    컴파일 오류 발생함 -> 이걸 보고 메서드명 수정하면 됨
     */

    /*
    * @Override
    * 이건 자바에서 기본적으로 제공하는 어노테이션
    *
    * 오버로딩(Overloading) 과 오버라이딩(Overriding) 비교! 아주 헷갈림
    *
    * 메서드 오버로딩 : 메서드 이름이 같고 매개변수(파라미터)가 다른 메서드를 여러개 정의하는 것을 메서드 오버로딩
    * 오버로딩을 번역하면 과적인데 과하게 물건을 담았는 뜻임
    * 따라서 같은 이름의 메서드를 여러 개 정의했다고 이해하면 됩니당
    *
    * 메서드 오버라이딩 : 하위 클래스에서 상위 클래스의 메서드를 재정의하는 과정을 의미한다.
    * 따라서 상속 관계에서 사용한다.
    * 부모의 기능을 자식이 다시 재정의하는 것이다.
    * 오버라이딩을 단순히 해석하면 무엇가를 넘어서 타는 것인데 자식의 새로운 기능이 부모의 기존 기능을 넘어 타서 기존 기능을 새로운 기능으로 덮어버린다고 이해해
    * 오버라이딩을 무언가를 다시 재정의한다고 해서 재정의라고 한다.
    *
    * 상속 관계에서는 기존 기능을 다시 정의한다고 이해하면 된다.
    * 실무에서는 메서드 오버라이딩, 메서드 재정의 둘 다 사용한다.
    */

    public void charge(){
        System.out.println("충전합니다.");
    }
}
